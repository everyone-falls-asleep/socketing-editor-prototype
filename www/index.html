<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Canvas 이미지 업로드 및 원 편집 도구</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
      }
      #myCanvas {
        position: absolute;
        top: 0;
        left: 0;
        /* width and height will be set via JavaScript */
      }
      #controls {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        z-index: 10;
        max-width: 220px;
        font-family: Arial, sans-serif;
      }
      #controls button,
      #controls input[type="file"],
      #controls label,
      #controls input[type="number"] {
        margin: 5px 2px;
        font-size: 14px;
        width: 100%;
        box-sizing: border-box;
      }
      #controls label {
        display: flex;
        align-items: center;
        cursor: pointer;
      }
      #controls input[type="checkbox"] {
        margin-right: 5px;
      }
      hr {
        margin: 10px 0;
        border: none;
        border-top: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas" tabindex="0"></canvas>
    <div id="controls">
      <input type="file" id="imageLoader" name="imageLoader" accept="image/*" />
      <button id="removeImage">이미지 제거</button>
      <hr />
      <button id="alignLeft">좌측 정렬</button>
      <button id="alignRight">우측 정렬</button>
      <button id="alignTop">상단 정렬</button>
      <button id="alignBottom">하단 정렬</button>
      <hr />
      <button id="distributeHorizontally">수평 분배</button>
      <button id="distributeVertically">수직 분배</button>
      <hr />
      <label>
        <input type="checkbox" id="toggleGrid" />
        격자 표시
      </label>
      <label>
        <input type="checkbox" id="toggleSnap" />
        스냅 사용
      </label>
      <label>
        격자 크기:
        <input type="number" id="gridSize" value="20" min="5" max="100" />
      </label>
      <hr />
      <button id="zoomIn">Zoom In (+)</button>
      <button id="zoomOut">Zoom Out (-)</button>
      <button id="resetZoom">Reset Zoom</button>
    </div>

    <script>
      const canvas = document.getElementById("myCanvas");
      const ctx = canvas.getContext("2d");
      canvas.focus(); // Canvas에 포커스 설정

      let circles = [];
      let selectedCircles = [];
      let clipboard = []; // 클립보드
      let undoStack = []; // Undo 스택
      let isSelecting = false;
      let isMoving = false;
      let startX, startY, currentX, currentY, offsetX, offsetY;
      let backgroundImage = null; // 배경 이미지
      let showGrid = false; // 격자 표시 여부
      let snapToGrid = false; // 스냅 사용 여부
      let gridSize = 20; // 기본 격자 간격

      let scale = 1.0; // 초기 확대/축소 비율
      const scaleFactor = 1.1; // 확대/축소 비율 단계

      // 컨트롤 요소들
      const imageLoader = document.getElementById("imageLoader");
      const removeImageButton = document.getElementById("removeImage");
      const zoomInButton = document.getElementById("zoomIn");
      const zoomOutButton = document.getElementById("zoomOut");
      const resetZoomButton = document.getElementById("resetZoom");
      const toggleGridCheckbox = document.getElementById("toggleGrid");
      const toggleSnapCheckbox = document.getElementById("toggleSnap");
      const gridSizeInput = document.getElementById("gridSize");

      // 이미지 로더 설정
      imageLoader.addEventListener("change", handleImage, false);

      // 이미지 제거 버튼 설정
      removeImageButton.addEventListener("click", removeImage, false);

      // 확대/축소 버튼 설정
      zoomInButton.addEventListener("click", () => zoom(scaleFactor));
      zoomOutButton.addEventListener("click", () => zoom(1 / scaleFactor));
      resetZoomButton.addEventListener("click", resetZoom);

      // 격자 토글 설정
      toggleGridCheckbox.addEventListener("change", function () {
        showGrid = this.checked;
        drawCanvas();
      });

      // 스냅 토글 설정
      toggleSnapCheckbox.addEventListener("change", function () {
        snapToGrid = this.checked;
        drawCanvas();
      });

      // 격자 크기 변경 설정
      gridSizeInput.addEventListener("change", function () {
        const value = parseInt(this.value);
        if (value >= 5 && value <= 100) {
          gridSize = value;
          drawCanvas();
        } else {
          alert("격자 크기는 5에서 100 사이의 값이어야 합니다.");
          this.value = gridSize;
        }
      });

      // 이미지 로딩 함수
      function handleImage(e) {
        const reader = new FileReader();
        reader.onload = function (event) {
          const img = new Image();
          img.onload = function () {
            backgroundImage = img;
            drawCanvas();
            updateRemoveImageButton();
          };
          img.src = event.target.result;
        };
        if (e.target.files[0]) {
          reader.readAsDataURL(e.target.files[0]);
        }
      }

      // 이미지 제거 함수
      function removeImage() {
        if (backgroundImage) {
          saveState(); // 상태 저장
          backgroundImage = null;
          drawCanvas();
          updateRemoveImageButton();
        }
      }

      // 상태 저장 함수
      function saveState() {
        const state = {
          circles: circles.map((circle) => ({ ...circle })),
          selectedCircles: selectedCircles.map((circle) => ({ ...circle })),
          backgroundImage: backgroundImage ? backgroundImage.src : null,
          scale: scale,
        };
        undoStack.push(state);
        if (undoStack.length > 50) {
          // 최대 50개까지 저장
          undoStack.shift();
        }
      }

      // 원 생성 함수
      function createCircle(x, y) {
        if (snapToGrid) {
          x = Math.round(x / gridSize) * gridSize;
          y = Math.round(y / gridSize) * gridSize;
        }
        saveState(); // 상태 저장
        circles.push({ x, y, radius: 15, selected: false });
        drawCanvas();
      }

      // 캔버스 그리기 함수
      function drawCanvas() {
        ctx.save();
        ctx.setTransform(scale, 0, 0, scale, 0, 0);
        ctx.clearRect(0, 0, canvas.width / scale, canvas.height / scale);

        // 격자 그리기 (배경 이미지 아래)
        if (showGrid) {
          drawGrid();
        }

        // 배경 이미지 그리기
        if (backgroundImage) {
          // 비율 유지하며 전체 캔버스에 맞추기
          const canvasAspect = canvas.width / scale / (canvas.height / scale);
          const imgAspect = backgroundImage.width / backgroundImage.height;
          let drawWidth, drawHeight;
          if (imgAspect > canvasAspect) {
            drawWidth = canvas.width / scale;
            drawHeight = canvas.width / scale / imgAspect;
          } else {
            drawHeight = canvas.height / scale;
            drawWidth = (canvas.height / scale) * imgAspect;
          }
          const drawX = (canvas.width / scale - drawWidth) / 2;
          const drawY = (canvas.height / scale - drawHeight) / 2;
          ctx.drawImage(backgroundImage, drawX, drawY, drawWidth, drawHeight);
        }

        // 원 그리기
        circles.forEach((circle) => {
          ctx.beginPath();
          ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
          ctx.fillStyle = circle.selected ? "green" : "blue";
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        });

        // 선택 박스 그리기
        if (isSelecting) {
          ctx.strokeStyle = "red";
          ctx.lineWidth = 1;
          ctx.setLineDash([5, 3]);
          ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
          ctx.setLineDash([]);
        }

        ctx.restore();
      }

      // 격자 그리기 함수
      function drawGrid() {
        ctx.strokeStyle = "#e0e0e0"; // 격자 색상
        ctx.lineWidth = 0.5;

        // 수직선
        for (let x = 0; x <= canvas.width / scale; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height / scale);
          ctx.stroke();
        }

        // 수평선
        for (let y = 0; y <= canvas.height / scale; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width / scale, y);
          ctx.stroke();
        }
      }

      // 선택된 원을 사각형 안에 있는지 확인하는 함수
      function selectCirclesInRect(x1, y1, x2, y2) {
        if (!event.ctrlKey) {
          deselectAllCircles();
        }
        circles.forEach((circle) => {
          if (
            circle.x >= x1 &&
            circle.x <= x2 &&
            circle.y >= y1 &&
            circle.y <= y2
          ) {
            if (event.ctrlKey && circle.selected) {
              circle.selected = false;
              selectedCircles = selectedCircles.filter((c) => c !== circle);
            } else {
              circle.selected = true;
              if (!selectedCircles.includes(circle)) {
                selectedCircles.push(circle);
              }
            }
          }
        });
        drawCanvas();
      }

      // 모든 원의 선택 해제 함수
      function deselectAllCircles() {
        selectedCircles = [];
        circles.forEach((circle) => (circle.selected = false));
        drawCanvas();
      }

      // 키 이벤트 핸들러
      document.addEventListener("keydown", (event) => {
        const key = event.key.toLowerCase();

        if (key === "delete" || key === "d") {
          if (selectedCircles.length > 0) {
            saveState(); // 상태 저장
            // 선택된 원 삭제
            circles = circles.filter((circle) => !circle.selected);
            selectedCircles = [];
            drawCanvas();
          }
        } else if (event.ctrlKey && key === "c") {
          // Ctrl+C: 선택된 원 복사
          clipboard = selectedCircles.map((circle) => ({ ...circle }));
        } else if (event.ctrlKey && key === "v") {
          if (clipboard.length > 0) {
            saveState(); // 상태 저장
            // Ctrl+V: 원 붙여넣기
            clipboard.forEach((circle) => {
              let newX = circle.x + 20 / scale; // 약간 이동 (확대/축소 비율 고려)
              let newY = circle.y + 20 / scale;
              if (snapToGrid) {
                newX = Math.round(newX / gridSize) * gridSize;
                newY = Math.round(newY / gridSize) * gridSize;
              }
              const newCircle = {
                x: newX,
                y: newY,
                radius: circle.radius,
                selected: true,
              };
              circles.push(newCircle);
              selectedCircles.push(newCircle);
            });
            drawCanvas();
          }
        } else if (event.ctrlKey && key === "z") {
          // Ctrl+Z: Undo 기능
          if (undoStack.length > 0) {
            const prevState = undoStack.pop();
            circles = prevState.circles.map((circle) => ({ ...circle }));
            selectedCircles = [];
            scale = prevState.scale || 1.0;
            if (prevState.backgroundImage) {
              const img = new Image();
              img.onload = function () {
                backgroundImage = img;
                drawCanvas();
                updateRemoveImageButton();
              };
              img.src = prevState.backgroundImage;
            } else {
              backgroundImage = null;
              drawCanvas();
              updateRemoveImageButton();
            }
          }
        }
      });

      // 마우스 이벤트 핸들러
      canvas.addEventListener("mousedown", (event) => {
        event.preventDefault(); // 기본 동작 방지
        canvas.focus(); // Canvas에 포커스 설정
        const rect = canvas.getBoundingClientRect();
        startX = (event.clientX - rect.left) / scale;
        startY = (event.clientY - rect.top) / scale;
        currentX = startX;
        currentY = startY;

        const clickedCircle = circles.find(
          (circle) =>
            Math.hypot(circle.x - startX, circle.y - startY) <= circle.radius
        );

        if (clickedCircle) {
          if (event.ctrlKey) {
            // Ctrl 키가 눌린 상태에서 클릭한 경우 선택 토글
            clickedCircle.selected = !clickedCircle.selected;
            if (clickedCircle.selected) {
              selectedCircles.push(clickedCircle);
            } else {
              selectedCircles = selectedCircles.filter(
                (c) => c !== clickedCircle
              );
            }
            drawCanvas();
          } else if (clickedCircle.selected) {
            // 선택된 원 위를 클릭한 경우 이동 시작
            isMoving = true;
            offsetX = startX;
            offsetY = startY;
          } else {
            // 기존 선택 해제 후 새 선택
            deselectAllCircles();
            clickedCircle.selected = true;
            selectedCircles = [clickedCircle];
            isMoving = true;
            offsetX = startX;
            offsetY = startY;
            drawCanvas();
          }
        } else if (selectedCircles.length > 0 && !event.ctrlKey) {
          // Ctrl 키가 눌리지 않은 상태에서 빈 공간을 클릭하면 선택 해제
          deselectAllCircles();
        } else {
          // 선택 박스 드래그 시작
          isSelecting = true;
        }
      });

      canvas.addEventListener("mousemove", (event) => {
        const rect = canvas.getBoundingClientRect();
        currentX = (event.clientX - rect.left) / scale;
        currentY = (event.clientY - rect.top) / scale;

        if (isSelecting) {
          drawCanvas();
        }

        if (isMoving) {
          const dx = currentX - offsetX;
          const dy = currentY - offsetY;
          selectedCircles.forEach((circle) => {
            circle.x += dx;
            circle.y += dy;
          });
          offsetX = currentX;
          offsetY = currentY;
          drawCanvas();
        }
      });

      canvas.addEventListener("mouseup", (event) => {
        if (isSelecting) {
          const x1 = Math.min(startX, currentX);
          const y1 = Math.min(startY, currentY);
          const x2 = Math.max(startX, currentX);
          const y2 = Math.max(startY, currentY);
          const dragDistance = Math.hypot(currentX - startX, currentY - startY);
          if (dragDistance < 5 / scale) {
            // 드래그 거리 고려
            saveState(); // 상태 저장
            createCircle(startX, startY);
          } else {
            selectCirclesInRect(x1, y1, x2, y2);
          }
          isSelecting = false;
          drawCanvas(); // 선택 박스 제거
        }
        if (isMoving) {
          if (snapToGrid) {
            saveState(); // 상태 저장
            selectedCircles.forEach((circle) => {
              circle.x = Math.round(circle.x / gridSize) * gridSize;
              circle.y = Math.round(circle.y / gridSize) * gridSize;
            });
            drawCanvas();
          } else {
            saveState(); // 상태 저장
          }
        }
        isMoving = false;
      });

      // 정렬 함수들
      function alignLeft() {
        if (selectedCircles.length === 0) return;
        saveState(); // 상태 저장
        const minX = Math.min(...selectedCircles.map((c) => c.x));
        selectedCircles.forEach((circle) => {
          circle.x = minX;
        });
        drawCanvas();
      }

      function alignRight() {
        if (selectedCircles.length === 0) return;
        saveState(); // 상태 저장
        const maxX = Math.max(...selectedCircles.map((c) => c.x));
        selectedCircles.forEach((circle) => {
          circle.x = maxX;
        });
        drawCanvas();
      }

      function alignTop() {
        if (selectedCircles.length === 0) return;
        saveState(); // 상태 저장
        const minY = Math.min(...selectedCircles.map((c) => c.y));
        selectedCircles.forEach((circle) => {
          circle.y = minY;
        });
        drawCanvas();
      }

      function alignBottom() {
        if (selectedCircles.length === 0) return;
        saveState(); // 상태 저장
        const maxY = Math.max(...selectedCircles.map((c) => c.y));
        selectedCircles.forEach((circle) => {
          circle.y = maxY;
        });
        drawCanvas();
      }

      function distributeHorizontally() {
        if (selectedCircles.length < 3) return;
        saveState(); // 상태 저장
        const sortedCircles = [...selectedCircles].sort((a, b) => a.x - b.x);
        const minX = sortedCircles[0].x;
        const maxX = sortedCircles[sortedCircles.length - 1].x;
        const gap = (maxX - minX) / (sortedCircles.length - 1);
        sortedCircles.forEach((circle, index) => {
          circle.x = minX + gap * index;
        });
        drawCanvas();
      }

      function distributeVertically() {
        if (selectedCircles.length < 3) return;
        saveState(); // 상태 저장
        const sortedCircles = [...selectedCircles].sort((a, b) => a.y - b.y);
        const minY = sortedCircles[0].y;
        const maxY = sortedCircles[sortedCircles.length - 1].y;
        const gap = (maxY - minY) / (sortedCircles.length - 1);
        sortedCircles.forEach((circle, index) => {
          circle.y = minY + gap * index;
        });
        drawCanvas();
      }

      // 버튼 이벤트 리스너 추가
      document.getElementById("alignLeft").addEventListener("click", alignLeft);
      document
        .getElementById("alignRight")
        .addEventListener("click", alignRight);
      document.getElementById("alignTop").addEventListener("click", alignTop);
      document
        .getElementById("alignBottom")
        .addEventListener("click", alignBottom);
      document
        .getElementById("distributeHorizontally")
        .addEventListener("click", distributeHorizontally);
      document
        .getElementById("distributeVertically")
        .addEventListener("click", distributeVertically);

      // 확대/축소 함수
      function zoom(factor) {
        scale *= factor;
        // 제한된 스케일 범위 설정 (예: 0.5x ~ 5x)
        scale = Math.min(Math.max(scale, 0.5), 5);
        drawCanvas();
      }

      // 확대/축소 리셋 함수
      function resetZoom() {
        scale = 1.0;
        drawCanvas();
      }

      // Remove Image 버튼 활성화/비활성화 함수
      function updateRemoveImageButton() {
        removeImageButton.disabled = !backgroundImage;
      }

      // 초기 버튼 상태 업데이트
      updateRemoveImageButton();

      // 창 크기 조정 함수
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        drawCanvas();
      }

      // 창 크기 변경 시 캔버스 크기 조정
      window.addEventListener("resize", resizeCanvas);

      // 마우스 휠을 이용한 확대/축소
      canvas.addEventListener(
        "wheel",
        (event) => {
          event.preventDefault();
          const delta = event.deltaY < 0 ? scaleFactor : 1 / scaleFactor;
          zoom(delta);
        },
        { passive: false }
      );

      // 초기 캔버스 크기 설정 및 그리기
      resizeCanvas();
    </script>
  </body>
</html>
